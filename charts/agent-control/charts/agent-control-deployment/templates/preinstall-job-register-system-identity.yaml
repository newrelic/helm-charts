{{- if include "newrelic-agent-control.auth.secret.shouldRunJob" . -}}
{{- /*
SystemIdentity currently supports userKey and L1/L2 identities. (userKey to be deprecated)
Both user key secret or L1/L2 identities are used only in the step that create the system identity.
The secret that is created by the common-library does not allow to add annotations so the secret is removed
once the installation hook is finished, so I have to add it as a hook.

As both ways co-exist, we'll add a check to ensure at least one exits
*/ -}}
{{- if and (not (include "newrelic.common.userKey._customSecretName" .)) (not (include "newrelic.common.userKey._userKey" .)) (not (include "newrelic-agent-control.auth.customl1IdentitySecretName" .)) (not (include "newrelic-agent-control.auth.l1Identity" .)) -}}
  {{- fail "You must specify a userKey/customUserKeySecretName or l1Identity/customl1IdentitySecretName" -}}
{{- end -}}

{{- if and (not (include "newrelic.common.userKey._customSecretName" .)) (include "newrelic.common.userKey._userKey" .) }}
---
apiVersion: v1
kind: Secret
metadata:
  annotations:
    helm.sh/hook: pre-install,pre-upgrade
    helm.sh/hook-delete-policy: before-hook-creation,hook-succeeded
    helm.sh/hook-weight: "-1010"
  labels:
    {{- include "newrelic.common.labels" . | nindent 4 }}
  name: {{ include "newrelic.common.naming.truncateToDNSWithSuffix" (dict "name" (include "newrelic.common.naming.fullname" .) "suffix" "preinstall-user-key" ) }}
  namespace: {{ .Release.Namespace }}
data:
  {{ include "newrelic.common.userKey.secretKeyName" . }}: {{ include "newrelic.common.userKey._userKey" . | b64enc }}
{{- end }}

{{/* L1/L2 Client Credentials */}}
{{- if and (not (include "newrelic-agent-control.auth.customl1IdentitySecretName" .)) (include "newrelic-agent-control.auth.l1Identity" .) }}
---
apiVersion: v1
kind: Secret
metadata:
  annotations:
    helm.sh/hook: pre-install,pre-upgrade
    helm.sh/hook-delete-policy: before-hook-creation,hook-succeeded
    helm.sh/hook-weight: "-1010"
  labels:
    {{- include "newrelic.common.labels" . | nindent 4 }}
  name: {{ include "newrelic-agent-control.auth.generatedIdentityCredentialsSecretName" . }}
  namespace: {{ .Release.Namespace }}
data:
  {{ include "newrelic-agent-control.auth.l1IdentityCredentialsKey.clientIdKeyName" . }}: {{ include "newrelic-agent-control.auth.l1IdentityClientId" . | b64enc }}
  {{ include "newrelic-agent-control.auth.l1IdentityCredentialsKey.clientSecretKeyName" . }}: {{ include "newrelic-agent-control.auth.l1IdentityClientSecret" . | b64enc }}
{{- end }}
---
apiVersion: batch/v1
kind: Job
metadata:
  annotations:
    helm.sh/hook: pre-install,pre-upgrade
    helm.sh/hook-delete-policy: before-hook-creation,hook-succeeded
    helm.sh/hook-weight: "-1005"
  name: {{ include "newrelic.common.naming.truncateToDNSWithSuffix" (dict "name" (include "newrelic.common.naming.fullname" .) "suffix" "system-identity-installer" ) }}
  namespace: {{ .Release.Namespace }}
spec:
  ttlSecondsAfterFinished: 120
  template:
    spec:
      restartPolicy: Never
      serviceAccountName: {{ include "newrelic.common.naming.truncateToDNSWithSuffix" (dict "name" (include "newrelic.common.serviceAccount.name" .) "suffix" "auth" ) }}
      containers:
        - name: register-system-identity
          image: alpine
          env:
            {{- if or  (include "newrelic.common.userKey._customSecretName" .) (include "newrelic.common.userKey._userKey" .) }}
            - name: USER_KEY
              valueFrom:
                secretKeyRef:
                  {{- if include "newrelic.common.userKey._customSecretName" . }}
                  name: {{ include "newrelic.common.userKey.secretName" . }}
                  {{- else }}
                  name: {{ include "newrelic.common.userKey.generatedSecretName" . }}
                  {{- end }}
                  key: {{ include "newrelic.common.userKey.secretKeyName" . }}
            {{- end }}
            {{- if or (include "newrelic-agent-control.auth.customl1IdentitySecretName" .) (include "newrelic-agent-control.auth.l1Identity" .) }}
            - name: NEW_RELIC_AUTH_CLIENT_ID
              valueFrom:
                secretKeyRef:
                  name: {{ include "newrelic-agent-control.auth.identityCredentialsSecretName" . }}
                  key: {{ include "newrelic-agent-control.auth.l1IdentityCredentialsKey.clientIdKeyName" . }}
            - name: NEW_RELIC_AUTH_CLIENT_SECRET
              valueFrom:
                secretKeyRef:
                  name: {{ include "newrelic-agent-control.auth.identityCredentialsSecretName" . }}
                  key: {{ include "newrelic-agent-control.auth.l1IdentityCredentialsKey.clientSecretKeyName" . }}
            {{- end }}
          command:
            - ash
          args:
            - -c
            - |
              set -euo pipefail
              apk update
              apk add kubectl

              echo Checking if the secret '{{ include "newrelic-agent-control.auth.secret.name" . }}' is already present in the cluster
              if kubectl get secret {{ include "newrelic-agent-control.auth.secret.name" . }}; then
                echo System identity already exists. Exiting gracefully...
                exit 0
              fi

              echo Generating the Keys...
              apk add curl jq openssl
              TEMPORAL_FOLDER=gen-folder
              mkdir $TEMPORAL_FOLDER
              openssl genrsa -out "$TEMPORAL_FOLDER/key" 4096
              openssl rsa -in "$TEMPORAL_FOLDER/key" -pubout -out "$TEMPORAL_FOLDER/pub"

              echo Key generated, creating the identity...
              if [ "${NEW_RELIC_AUTH_CLIENT_ID:-}" != "" ] && [ "${NEW_RELIC_AUTH_CLIENT_SECRET:-}" != "" ]; then
                echo Starting with L1/L2 System Identity...
                ############################################################
                # Get the L1 Access Token
                ############################################################
                RESPONSE_FILE=$TEMPORAL_FOLDER/response_token.json
                for RETRY in 1 2 3; do
                  HTTP_CODE=$(echo '{"client_id": "'$NEW_RELIC_AUTH_CLIENT_ID'", "client_secret": "'$NEW_RELIC_AUTH_CLIENT_SECRET'", "grant_type": "client_credentials"}' | tr -d $'\n' | curl \
                    -s -w "%{http_code}" \
                    -H "Content-Type: application/json" \
                    -o "$RESPONSE_FILE" \
                    --data-binary @- \
                    "{{ include "newrelic-agent-control.config.endpoints.tokenRenewal" . }}"
                  )

                  if [ $HTTP_CODE -eq 200 ]; then
                    break
                  fi

                  ERROR_MESSAGE=$(jq '.error_description // "invalid_request"' < "$TEMPORAL_FOLDER/response_token.json" | tr -d '"')

                  echo "Error getting system identity auth token. The API endpoint returned $HTTP_CODE: $ERROR_MESSAGE. Retrying ($RETRY/3)..."
                  sleep 2
                done

                if [ $HTTP_CODE -ne 200 ]; then
                  echo "Error getting system identity auth token"
                  exit 99
                fi

                ACCESS_TOKEN=$(jq  '.access_token' < "$RESPONSE_FILE" | tr -d '"' )

                ############################################################
                # Create System Identity (L1/L2 System Identities)
                ############################################################
                DATE=$(date -u +"%Y-%m-%dT%H:%M:%SZ")
                NAME="System Identity for $(hostname) - $DATE"

                for RETRY in 1 2 3; do
                  HTTP_CODE=$(echo '{ "query":
                      "mutation {
                        create(
                          name: \"'$NAME'\",
                          organizationId: \"{{ include "newrelic-agent-control.auth.organizationId" . }}\",
                          publicKey: \"'$(openssl enc -base64 -A -in "$TEMPORAL_FOLDER/pub")'\"
                        ) {
                          clientId,
                          name
                        }
                      }"
                    }' | tr -d $'\n' | curl \
                      -s -w "%{http_code}" \
                      -H "Content-Type: application/json" \
                      -H "Authorization: Bearer $ACCESS_TOKEN" \
                      -o "$TEMPORAL_FOLDER/response.json" \
                      --data-binary @- \
                      "{{ include "newrelic-agent-control.config.endpoints.systemIdentityCreation" . }}"
                  )

                  if [ $HTTP_CODE -eq 200 ]; then
                    break
                  fi

                  echo "Error creating L2 system identity. The API endpoint returned $HTTP_CODE. Retrying ($RETRY/3)..."
                  sleep 2
                done

                if [ $HTTP_CODE -ne 200 ]; then
                  exit 99
                fi

                ERROR_MESSAGE=$(jq '.errors[0].message // "NOERROR"' < "$TEMPORAL_FOLDER/response.json" | tr -d '"')
                if [ "$ERROR_MESSAGE" != "NOERROR" ]; then
                  echo "Failed to create a New Relic System Identity for Fleet Control communication authentication. Please verify that your User Key is valid and that your Account Organization has the necessary permissions to create a System Identity: $ERROR_MESSAGE"
                  exit 100
                fi

                CLIENT_ID=$(jq  '.data.create.clientId' < "$TEMPORAL_FOLDER/response.json" | tr -d '"' )
              else
                echo Starting with Legacy UserApiKey System Identity...
                ############################################################
                # Create System Identity (Legacy)
                ############################################################
                for RETRY in 1 2 3; do
                  HTTP_CODE=$(echo '{ "query":
                      "mutation {
                        systemIdentityCreate(
                          name: \"System Identity for Kubernetes cluster '{{ include "newrelic.common.cluster" . }}'\",
                          organizationId: \"{{ include "newrelic-agent-control.auth.organizationId" . }}\",
                          publicKey: \"'$(openssl enc -base64 -A -in "$TEMPORAL_FOLDER/pub")'\"
                        ) {
                          clientId,
                          name
                        }
                      }"
                    }' | tr -d $'\n' | \
                    curl \
                      -w "%{http_code}" \
                      -H "Content-Type: application/json" \
                      -H "API-Key: $USER_KEY" \
                      -o "$TEMPORAL_FOLDER/response.json" \
                      --data @- \
                      "{{ include "newrelic-agent-control.config.endpoints.systemIdentityRegistration" . }}"
                  )
                  if [ $HTTP_CODE -eq 200 ]; then
                    break
                  fi
                  echo "Error creating the new system identity. The API endpoint returned $HTTP_CODE. Retrying ($RETRY/3)..."
                  sleep 2
                done
                if [ $HTTP_CODE -ne 200 ]; then echo HTTP_CODE=$HTTP_CODE ;exit 1; fi

                ERROR_MESSAGE=$(jq -r '.errors[0].message // "NOERROR"' "$TEMPORAL_FOLDER/response.json")
                if [ "$ERROR_MESSAGE" != "NOERROR" ]; then
                  echo "Failed to create a New Relic System Identity for Fleet Control communication authentication. Please verify that your User Key is valid and that your Account Organization has the necessary permissions to create a System Identity: $ERROR_MESSAGE"
                  exit 1
                fi

                CLIENT_ID=$(jq -r '.data.systemIdentityCreate.clientId' "$TEMPORAL_FOLDER/response.json")
              fi
              echo Creating the secret '{{ include "newrelic-agent-control.auth.secret.name" . }}'...
              kubectl create secret generic --dry-run=client -o json \
                {{ include "newrelic-agent-control.auth.secret.name" . }} \
                --from-literal=CLIENT_ID=$CLIENT_ID \
                --from-file="private_key=$TEMPORAL_FOLDER/key" | \
              jq '.metadata.labels |= {{ include "newrelic.common.labels" . | fromYaml | toJson }}' | \
              kubectl apply -n "{{ .Release.Namespace }}" -f -
---
{{ if .Values.rbac.create }}
apiVersion: rbac.authorization.k8s.io/v1
kind: ClusterRole
metadata:
  annotations:
    helm.sh/hook: pre-install,pre-upgrade
    helm.sh/hook-delete-policy: before-hook-creation,hook-succeeded
    helm.sh/hook-weight: "-1010"
  labels:
    {{- include "newrelic.common.labels" . | nindent 4 }}
  name: {{ include "newrelic.common.naming.truncateToDNSWithSuffix" (dict "name" (include "newrelic.common.naming.fullname" .) "suffix" "auth") }}
  namespace: {{ .Release.Namespace }}
rules:
  - apiGroups: [ "" ]
    resources: [ "secrets" ]
    verbs:
      - create
      - patch
      - update
      - get
---
apiVersion: rbac.authorization.k8s.io/v1
kind: RoleBinding
metadata:
  annotations:
    helm.sh/hook: pre-install,pre-upgrade
    helm.sh/hook-delete-policy: before-hook-creation,hook-succeeded
    helm.sh/hook-weight: "-1009"
  labels:
    {{- include "newrelic.common.labels" . | nindent 4 }}
  name: {{ include "newrelic.common.naming.truncateToDNSWithSuffix" (dict "name" (include "newrelic.common.naming.fullname" .) "suffix" "auth") }}
  namespace: {{ .Release.Namespace }}
roleRef:
  apiGroup: rbac.authorization.k8s.io
  kind: ClusterRole
  name: {{ include "newrelic.common.naming.truncateToDNSWithSuffix" (dict "name" (include "newrelic.common.naming.fullname" .) "suffix" "auth") }}
subjects:
  - kind: ServiceAccount
    name: {{ include "newrelic.common.naming.truncateToDNSWithSuffix" (dict "name" (include "newrelic.common.serviceAccount.name" .) "suffix" "auth" ) }}
    namespace: {{ .Release.Namespace }}
{{- end }}

{{- if include "newrelic.common.serviceAccount.create" . }}
---
apiVersion: v1
kind: ServiceAccount
metadata:
  annotations:
    helm.sh/hook: pre-install,pre-upgrade
    helm.sh/hook-delete-policy: before-hook-creation,hook-succeeded
    helm.sh/hook-weight: "-1010"
  {{- if include "newrelic.common.serviceAccount.annotations" . }}
    {{- include "newrelic.common.serviceAccount.annotations" . | nindent 4 }}
  {{- end }}
  labels:
    {{- include "newrelic.common.labels" . | nindent 4 }}
  name: {{ include "newrelic.common.naming.truncateToDNSWithSuffix" (dict "name" (include "newrelic.common.serviceAccount.name" .) "suffix" "auth" ) }}
  namespace: {{ .Release.Namespace }}
{{- end -}}
{{- end -}}
