# Default values for nri-bundle.
# This is a YAML-formatted file.
# Declare variables to be passed into your templates.

# enables newrelic-infrastructure
infrastructure:
  enabled: true

# enables nri-prometheus
prometheus:
  enabled: false

# enables nri-metadata-injection
webhook:
  enabled: true

# enables kube-state-metrics
ksm:
  enabled: true

# enables nri-kube-events
kubeEvents:
  enabled: true

# enables newrelic-logging
logging:
  enabled: true

# enables newrelic-pixie
newrelic-pixie:
  enabled: false

# enables pixie-chart
pixie-chart:
  enabled: false

# enables newrelic-infra-operator
newrelic-infra-operator:
  enabled: false

# IMPORTANT: the following values are set as global so that they
# can be shared by other newrelic product's charts
#
#   - Specify either the New Relic keys or the secret which
#   contains them.
#
#   - Specify the Kubernetes cluster name.
#     https://docs.newrelic.com/docs/kubernetes-monitoring-integration
#
# global:
#   licenseKey:
#   insightsKey:
#   customSecretName:
#   customSecretLicenseKey:
#   customSecretInsightsKey:
#   cluster:
#   # IMPORTANT: Set this to true when deploying in EKS Fargate. This will pull the sidecar injector operator chart to
#   # automatically monitor fargate workloads, and also prevent the DaemonSet from being scheduled in Fargate nodes
#   fargate: true

# It is possible to configure dependencies values from this chart.
# For example you can configure `verboseLog` variable of the newrelic-infrastructure chart installed as a dependency and enable openshift configs as follows.

# newrelic-infrastructure:
#   verboseLog: true
#   openshift:
#     enabled: true
#     version: "4.x"

# The same approach can be followed to update any of the dependencies.
# https://helm.sh/docs/chart_template_guide/subcharts_and_globals

# If you wish to monitor services running on Kubernetes you can provide integrations
# configuration under integrations_config that is pass down to the newrelic-infrastructure chart. You just need to create a new entry where
# the "name" is the filename of the configuration file and the data is the content of
# the integration configuration. The name must end in ".yaml" as this will be the
# filename generated and the Infrastructure agent only looks for YAML files. The data
# part is the actual integration configuration as described in the spec here:
# https://docs.newrelic.com/docs/integrations/integrations-sdk/file-specifications/integration-configuration-file-specifications-agent-v180

# For example, if you wanted do to monitor a Redis instance that has a label "app=redis"
# you could do so by adding following entry:
#
# newrelic-infrastructure:
#   integrations_config:
#     - name: nri-redis.yaml
#       data:
#         discovery:
#           command:
#             # Run NRI Discovery for Kubernetes
#             # https://github.com/newrelic/nri-discovery-kubernetes
#             exec: /var/db/newrelic-infra/nri-discovery-kubernetes
#             match:
#               label.app: redis
#         integrations:
#           - name: nri-redis
#             env:
#               # using the discovered IP as the hostname address
#               HOSTNAME: ${discovery.ip}
#               PORT: 6379
#             labels:
#               env: test

# New Relic default configuration for fluent-bit.conf (service, inputs, filters, outputs)
# and parsers.conf (parsers). The configuration below is not configured for lowDataMode and will
# send all attributes.  If custom configuration is required, update these variables.
# newrelic-logging:
#   fluentBit:
#     config:
#       service: |
#         [SERVICE]
#             Flush         1
#             Log_Level     ${LOG_LEVEL}
#             Daemon        off
#             Parsers_File  parsers.conf
#             HTTP_Server   On
#             HTTP_Listen   0.0.0.0
#             HTTP_Port     2020

#       inputs: |
#         [INPUT]
#             Name              tail
#             Tag               kube.*
#             Path              ${PATH}
#             Parser            ${LOG_PARSER}
#             DB                ${FB_DB}
#             Mem_Buf_Limit     7MB
#             Skip_Long_Lines   On
#             Refresh_Interval  10

#       filters: |
#         [FILTER]
#             Name           kubernetes
#             Match          kube.*
#             # We need the full DNS suffix as Windows only supports resolving names with this suffix
#             # See: https://kubernetes.io/docs/setup/production-environment/windows/intro-windows-in-kubernetes/#dns-limitations
#             Kube_URL       https://kubernetes.default.svc.cluster.local:443
#             K8S-Logging.Exclude ${K8S_LOGGING_EXCLUDE}

#         [FILTER]
#             Name           record_modifier
#             Match          *
#             Record         cluster_name ${CLUSTER_NAME}

#       outputs: |
#         [OUTPUT]
#             Name           newrelic
#             Match          *
#             licenseKey     ${LICENSE_KEY}
#             endpoint       ${ENDPOINT}
#             lowDataMode    ${LOW_DATA_MODE}

#       parsers: |
#         [PARSER]
#             Name         docker
#             Format       json
#             Time_Key     time
#             Time_Format  %Y-%m-%dT%H:%M:%S.%L
#             Time_Keep    On

#         [PARSER]
#             Name cri
#             Format regex
#             Regex ^(?<time>[^ ]+) (?<stream>stdout|stderr) (?<logtag>[^ ]*) (?<message>.*)$
#             Time_Key    time
#             Time_Format %Y-%m-%dT%H:%M:%S.%L%z